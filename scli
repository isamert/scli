#!/usr/bin/env python3

# pylint: disable=invalid-name, ungrouped-imports, too-many-lines, missing-docstring, line-too-long

import os
import re
import sys
import json
import subprocess
import tempfile
import atexit
import argparse
import logging
import errno
import textwrap
import bisect
import shlex
from subprocess import PIPE, Popen
from datetime import datetime
import base64
import collections

import urwid

try:
    from urwid_readline import ReadlineEdit

    Edit = ReadlineEdit
except ImportError:
    Edit = urwid.Edit

# #############################################################################
# constants
# #############################################################################

DATA_FOLDER = os.getenv('XDG_DATA_HOME', os.path.expanduser('~/.local/share'))
CFG_FOLDER = os.getenv('XDG_CONFIG_HOME', os.path.expanduser('~/.config'))

SIGNALCLI_LEGACY_FOLDER = os.path.join(CFG_FOLDER, 'signal')
SIGNALCLI_LEGACY_DATA_FOLDER = os.path.join(SIGNALCLI_LEGACY_FOLDER, 'data')
SIGNALCLI_LEGACY_ATTACHMENT_FOLDER = os.path.join(SIGNALCLI_LEGACY_FOLDER, 'attachments')

SIGNALCLI_FOLDER = os.path.join(DATA_FOLDER, 'signal-cli')
SIGNALCLI_DATA_FOLDER = os.path.join(SIGNALCLI_FOLDER, 'data')
SIGNALCLI_ATTACHMENT_FOLDER = os.path.join(SIGNALCLI_FOLDER, 'attachments')

SCLI_DATA_FOLDER = os.path.join(DATA_FOLDER, 'scli')
SCLI_HISTORY_FILE = os.path.join(SCLI_DATA_FOLDER, 'history')
SCLI_CFG_FILE = os.path.join(CFG_FOLDER, 'sclirc')
SCLI_LOG_FILE = os.path.join(SCLI_DATA_FOLDER, 'log')

# #############################################################################
# coloring stuff
# #############################################################################

# TODO: make costumizable

PALETTE = [
    ('normal', '', ''),
    ('box_normal', '', ''),
    ('box_focused', 'dark blue', ''),
    ('bold', 'bold', ''),
    ('italic', 'italics', ''),
    ('strikethrough', 'strikethrough', ''),
    ('bolditalic', 'italics,bold', ''),
    ('reversed', 'standout', ''),
    ('reverseditalic', 'standout,italics', ''),
]

LIST_FOCUS_MAP = {
    None: 'reversed',
    'normal': 'reversed',
    'bold': 'reversed',
    'italic': 'reversed',
    'strikethrough': 'reversed',
    'bolditalic': 'reversed',
}

FORMAT_MAP = {'_': 'italic', '*': 'bold', '~': 'strikethrough'}


def ibtxt(txt):
    return ('bolditalic', txt)


def ntxt(txt):
    return ('normal', txt)


def btxt(txt):
    return ('bold', txt)


def itxt(txt):
    return ('italic', txt)


def to_txt(txt):
    if isinstance(txt, str):
        return txt
    elif isinstance(txt, tuple):
        return txt[1]
    else:
        return ''.join([to_txt(t) for t in txt])


# #############################################################################
# utility
# #############################################################################


def has_key(key, x):
    if x:
        return key in x
    return False


def get_nested(dct, *keys, default=None):
    for key in keys:
        try:
            dct = dct[key]
        except (KeyError, TypeError, IndexError):
            return default
    return dct


def get_urls(txt):
    return re.findall(r'(https?://[^\s]+)', txt)


def mk_call(cmd, rmap=None, disown=False, use_pipe=True):
    if not rmap:
        rmap = {}

    for key, val in rmap.items():
        cmd = cmd.replace(key, val)

    if disown:
        with open(os.devnull, 'w') as f:
            subprocess.Popen(cmd, shell=True, stdout=f, stderr=f, preexec_fn=os.setpgrp)
    else:
        if use_pipe:
            pipe = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        else:
            pipe = subprocess.Popen(cmd, shell=True)

        out, err = pipe.communicate()
        logging.info('mk_call:%s', cmd)
        try:
            if pipe.returncode == 0:
                logging.info('mk_call:exit_0:%s', out.decode('utf-8'))
            else:
                logging.critical('mk_call:exit_%d:%s', pipe.returncode, err.decode('utf-8'))
        except AttributeError:
            pass

        return out


def is_number(number):
    # https://github.com/signalapp/libsignal-service-java/blob/master/java/src/main/java/org/whispersystems/signalservice/api/util/PhoneNumberFormatter.java
    return bool(re.match('^\\+[1-9][0-9]{6,14}$', number))


class ObservableConfig:
    signals = ['changed']

    def __init__(self, cfg_obj):
        self._cfg_obj = cfg_obj

    def __getattr__(self, name):
        return getattr(self._cfg_obj, name)

    def __setattr__(self, name, value):
        if name != '_cfg_obj' and hasattr(self._cfg_obj, name):
            setattr(self._cfg_obj, name, value)
            urwid.emit_signal(self, 'changed', name, value)
        else:
            super().__setattr__(name, value)


urwid.register_signal(ObservableConfig, ObservableConfig.signals)

# #############################################################################
# signal utility
# #############################################################################


def hash_contact(x):
    h = x.get('number') or x.get('groupId')
    if h is None:
        logging.critical('hash_contact:No number or groupId')
    return h


def get_contact_name(x):
    if not x:
        logging.critical('get_contact_name:empty sender')
        return "NULL"

    if isinstance(x, str):
        return x

    name = x.get('name')
    if name and not name.isspace():
        return name

    return get_contact_number(x)


def get_contact_number(x):
    if not x:
        logging.critical('get_contact_number:empty sender')
        return "NULL"

    number = x.get('number')
    if number:
        return number

    return "NULL"


def get_contact_color(x):
    color = x.get('color')
    if color or color.strip(' ') != '':
        return color

    return 'white'


def is_contact_group(contact):
    return has_key('groupId', contact)


def is_envelope_outgoing(envelope):
    return 'target' in envelope or get_nested(envelope, 'syncMessage', 'sentMessage') is not None


def is_envelope_group_message(envelope):
    return (
        get_nested(envelope, 'dataMessage', 'groupInfo') is not None
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'groupInfo') is not None
        or (is_envelope_outgoing(envelope) and not is_number(envelope.get('target')))
    )


def get_envelope_msg(envelope):
    # If the `message` field is absent from the envelope: return None. If it is present but contains no text (since signal-cli v0.6.8, this is represented as `'message': null`): return ''. Otherwise: return the `message` field's value.
    for msg in (
        get_nested(envelope, 'dataMessage', 'message', default=0),
        get_nested(envelope, 'syncMessage', 'sentMessage', 'message', default=0),
    ):
        if msg is None:
            return ''
        elif msg != 0:
            return msg
    return None


def get_envelope_time(envelope):
    return (
        get_nested(envelope, 'dataMessage', 'timestamp')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'timestamp')
        or envelope['timestamp']
    )


def get_envelope_contact_id(envelope):
    return (
        envelope.get('target')
        or get_nested(envelope, 'dataMessage', 'groupInfo', 'groupId')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'groupInfo', 'groupId')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'destination')
        or envelope['source']
    )


def get_envelope_attachments(envelope):
    return (
        get_nested(envelope, 'dataMessage', 'attachments')
        or get_nested(envelope, 'syncMessage', 'sentMessage', 'attachments')
        or []
    )


def get_attachment_name(attachment):
    if isinstance(attachment, dict):
        filename = attachment['filename']
        return filename if filename is not None else attachment['contentType']
    else:
        return os.path.basename(attachment)


def get_attachment_path(attachment):
    if isinstance(attachment, dict):
        received_attachment = os.path.join(SIGNALCLI_ATTACHMENT_FOLDER, str(attachment['id']))
        if not os.path.exists(received_attachment):
            received_attachment = os.path.join(SIGNALCLI_LEGACY_ATTACHMENT_FOLDER, str(attachment['id']))
        return received_attachment
    elif isinstance(attachment, str) and os.path.exists(attachment):
        return attachment

def b64_to_bytearray(group_id):
    return ','.join(str(i) for i in base64.b64decode(group_id.encode()))


# #############################################################################
# ui utility
# #############################################################################


def listbox_focus_prev(listbox):
    try:
        listbox.focus_position = listbox.focus_position - 1
    except IndexError:
        pass


def listbox_focus_next(listbox):
    try:
        listbox.focus_position = listbox.focus_position + 1
    except IndexError:
        pass


def listbox_set_body(listbox, body_new):
    # Can't just do `listbox.body = body_new`:
    # https://github.com/urwid/urwid/issues/428
    urwid.disconnect_signal(listbox.body, "modified", listbox._invalidate)
    listbox.body = body_new
    urwid.connect_signal(listbox.body, "modified", listbox._invalidate)


class FocusableText(urwid.AttrMap):
    def __init__(self, markup, **kwargs):
        super().__init__(urwid.Text(markup, **kwargs), None, focus_map=LIST_FOCUS_MAP)

    def __lt__(self, wtxt):
        return get_envelope_time(self.envelope) < get_envelope_time(wtxt.envelope)


class NiceBox(urwid.AttrMap):
    def __init__(self, w, title=''):
        box = urwid.AttrMap(urwid.LineBox(urwid.AttrMap(w, 'normal'), title_align='center', title=title), 'box_normal')
        super().__init__(box, None, focus_map={'box_normal': 'box_focused'})


class PopUpWrapper(urwid.LineBox):
    signals = ['closed']

    def __init__(self, widget, buttons=True):
        self._widget = widget
        self._widget.result = None

        self._buttons = buttons
        if buttons:
            btn_ok = urwid.Button('OK')
            btn_cancel = urwid.Button('Cancel')
            self.buttons_grid = urwid.GridFlow([btn_ok, btn_cancel], 10, 1, 1, ('relative', 100))
            super().__init__(urwid.Frame(widget, footer=self.buttons_grid))
        else:
            super().__init__(widget)

    def keypress(self, size, key):
        if self._buttons:
            if key == 'tab':
                if self.original_widget.focus_position == 'footer':
                    if self.buttons_grid.focus_position == 0:
                        self.buttons_grid.focus_position = 1
                    else:
                        self.original_widget.focus_position = 'body'
                else:
                    self.buttons_grid.focus_position = 0
                    self.original_widget.focus_position = 'footer'
            # I'm not sure why I need to do this:
            elif self.original_widget.focus_position == 'body':
                self.original_widget.keypress(size, key)
            elif key == 'enter':
                if self.buttons_grid.focus_position == 0:
                    self._emit('closed', True, self._widget.result)
                else:
                    self._emit('closed', False, None)
                self._emit('closed', False, None)

        if key == 'q':
            self._emit('closed', False, None)


class MessageInfo(urwid.ListBox):
    def __init__(self, state, envelope):
        self.state = state

        source = envelope['source']
        msg = get_envelope_msg(envelope)
        date = None
        timestamp = get_envelope_time(envelope)
        try:
            date = datetime.utcfromtimestamp(timestamp)
        except ValueError:
            date = datetime.utcfromtimestamp(timestamp / 1000)
        date = date.strftime('%H:%M (%Y-%m-%d)')

        txt_name = FocusableText([btxt('Name   : '), ntxt(get_contact_name(state.signal.get_contact(source)))])
        txt_source = FocusableText([btxt('Number : '), ntxt(source)])
        txt_date = FocusableText([btxt('Date   : '), ntxt(date)])
        txt_msg = FocusableText([btxt('Message: '), ntxt(msg)])
        txt_urls = FocusableText([btxt('Links')], align='center')

        urls = []
        for url in get_urls(msg):
            txt_url = FocusableText([ntxt(url)])
            txt_url.full_path = url
            urls.append(txt_url)

        txt_atchs = FocusableText(btxt('Attachments'), align='center')

        atchs = []
        for atch in get_envelope_attachments(envelope):
            txt_atch = FocusableText(ntxt(get_attachment_name(atch)))
            txt_atch.original_widget.full_path = get_attachment_path(atch)
            atchs.append(txt_atch)

        items = [txt_name, txt_source, txt_date, txt_msg, txt_urls, *urls, txt_atchs, *atchs]
        super().__init__(urwid.SimpleFocusListWalker(items))

    def keypress(self, size, key):
        item = self.body[self.focus_position].original_widget

        if key in ('j', 'down'):
            listbox_focus_next(self)
        elif key in ('k', 'up'):
            listbox_focus_prev(self)
        elif key == 'y':
            text, _ = item.get_text()
            try:
                clip.put(self.state, item.full_path)
            except AttributeError:
                try:
                    clip.put(self.state, text.split(": ")[1])
                except IndexError:
                    clip.put(self.state, text)
        elif key in ('enter', 'o'):
            try:
                self.state.commands.open_file(item.full_path)
            except (AttributeError, TypeError):
                pass


class HelpDialog(urwid.ListBox):
    def __init__(self):
        items = []
        items.append(urwid.Text(btxt("Keybindings")))
        items.append(urwid.Text(btxt("Commands")))
        super().__init__(urwid.SimpleFocusListWalker(items))


# #############################################################################
# clipboard
# #############################################################################


class clip:
    mime_order = ['image/png', 'image/jpeg', 'image/jpg', 'text/uri-list']
    tempfile_prefix = '_scli-tmp.'

    @staticmethod
    def xrun(mime):
        try:
            p = Popen(['xclip', '-selection', 'clipboard', '-t', mime, '-o'], stdout=PIPE, stderr=PIPE)
        except OSError:
            return
        out, err = p.communicate()
        return out

    @staticmethod
    def xrun_lines(mime):
        out = clip.xrun(mime)
        if out:
            return out.decode('utf-8').split('\n')

    @staticmethod
    def xfiles():
        out = clip.xrun_lines('TARGETS')

        for otype in out:
            for mtype in clip.mime_order:
                if mtype == otype:
                    if mtype.startswith('image/'):
                        content = clip.xrun(mtype)
                        suffix = '.' + mtype.split('/')[1]
                        tmp = tempfile.NamedTemporaryFile(
                            mode='w+b', prefix=clip.tempfile_prefix, suffix=suffix, delete=False
                        )
                        tmp.write(content)
                        tmp.flush()
                        tmp.close()
                        return [tmp.name]
                    elif mtype == 'text/uri-list':
                        content = clip.xrun_lines(mtype)
                        return [x.replace('file://', '') for x in content[1:]]

    @staticmethod
    def xput(txt):
        if not txt:
            return
        try:
            p = Popen(['xclip', '-selection', 'clipboard'], stdout=PIPE, stderr=PIPE, stdin=PIPE)
        except OSError:
            return
        p.stdin.write(bytes(txt, 'utf-8'))
        p.stdin.close()
        p.wait()

    @staticmethod
    def put(state, txt):
        cmd = state.cfg.clipboard_put_command
        if cmd == "":
            return clip.xput(txt)

        return mk_call(cmd, {'%s': txt})

    @staticmethod
    def files(state):
        cmd = state.cfg.clipboard_get_command
        if cmd == "":
            return clip.xfiles()

        return mk_call(cmd).split('\n')


# #############################################################################
# AsyncProc & Daemon
# #############################################################################


class AsyncProc:

    def __init__(self, urwid_loop):
        self._urwid_loop = urwid_loop

    def run(self, args, callback=None, *callback_args, shell=False, **callback_kwargs):
        """ Run the command composed of `args` in the background (asynchronously); run the `callback` function when it finishes """

        def watchpipe_handler(line):
            # This function is run when the shell process returns (finishes execution).
            # The `line` printed to watch pipe is of the form "b'<PID> <RETURN_CODE>\n'"
            _proc_pid, return_code = [int(i) for i in line.decode().split()]
            proc.wait()  # reap the child process, to prevent zombies

            proc.returncode = return_code   # overwrite the 'wrapper' command return code (always 0) with the actual command return code
            proc.output = proc.stderr.read().rstrip('\n')   # stderr stream is not seekable, so can be read only once

            if return_code != 0:
                logging.error('proc: cmd:`%s`; return_code:%d; output:"%s"', proc.args, return_code, proc.output)

            if callback is not None:
                callback(proc, *callback_args, **callback_kwargs)

            os.close(watchpipe_fd) # Close the write end of urwid's watch pipe.
            return False # Close the read end of urwid's watch pipe and remove the watch from event_loop.

        watchpipe_fd = self._urwid_loop.watch_pipe(watchpipe_handler)

        # If the command is run with Popen(.., shell=True), shlex.quote is needed to escape special chars in args.
        sh_command = " ".join([shlex.quote(arg) for arg in args] if not shell else ['{', args, ';', '}'])
        # Redirect all the process's output to stderr, and write the process PID and exit status to the watch pipe.
        sh_command += " 1>&2; echo $$ $?"

        proc = Popen(sh_command, shell=True, stdout=watchpipe_fd, stderr=PIPE, universal_newlines=True)
        atexit.register(proc.kill)   # prevent orphaned processes surviving after the main program is stopped
        return proc


class Daemon(AsyncProc):

    def start(self, username, envelope_handler):
        self._envelope_handler = envelope_handler
        self._buffer = b''

        stdout_fd = self._urwid_loop.watch_pipe(self._daemon_handler)
        stderr_fd = self._urwid_loop.watch_pipe(self._daemon_stderr_handler)
        return Popen(['signal-cli', '-u', username, 'daemon', '--json'], stdout=stdout_fd, stderr=stderr_fd, close_fds=True)

    def _daemon_handler(self, line):
        line = self._buffer + line
        lines = line.split(b'\n')
        if lines[-1] != b'':
            # Not a complete message. Store in buffer
            self._buffer = lines[-1]
        else:
            self._buffer = b''

        # The last item is either empty or an incomplete message, so we don't process it
        for line in lines[:-1]:
            if not line.strip():
                continue
            try:
                e = json.loads(line.decode('utf-8'))
                envelope = e['envelope']
                self._envelope_handler(envelope)
            except Exception as e:
                logging.error('input: %s', line)
                logging.exception(e)
                # TODO: display error to user
                continue

    def _daemon_stderr_handler(self, line):
        line = line.decode().strip()
        if not line:
            return
        logging.error('stderr: %s', line)

    def dbus_send(self, args, *proc_args, async_proc=True, **proc_kwargs):
        """ Send a command to signal-cli daemon through dbus """
        args = [
                    'dbus-send',
                    '--session',
                    '--type=method_call',
                    '--print-reply',
                    '--dest=org.asamk.Signal',
                    '/org/asamk/Signal',
                    *args
                ]
        if async_proc:
            proc = self.run(args, *proc_args, **proc_kwargs)
        else:
            proc = subprocess.run(args, *proc_args, **proc_kwargs)
        return proc

    def send_message(self, message, attachments, recipient, is_group=False, *proc_args, **proc_kwargs):
        args = [
                ('org.asamk.Signal.sendMessage'
                    if not is_group else
                    'org.asamk.Signal.sendGroupMessage'),
                'string:' + message,
                'array:string:' + ','.join(attachments),
                ('string:' + recipient
                    if not is_group else
                    'array:byte:' + b64_to_bytearray(recipient))
                ]

        self.dbus_send(args, *proc_args, **proc_kwargs)

    def rename_contact(self, contact_id, new_name, is_group=False, *proc_args, **proc_kwargs):
        """Rename a contact or group.

        If a contact does not exist, it will be created. Changes to groups are sent to the server, changes to individual contacts are local.
        """
        if not is_group:
            args = ["org.asamk.Signal.setContactName",
                    "string:" + contact_id,
                    "string:" + new_name]
        else:
            args = ["org.asamk.Signal.updateGroup",
                    "array:byte:" + b64_to_bytearray(contact_id),
                    "string:" + new_name,
                    "array:string:" + '',   # members
                    "string:" + '']         # avatar
        self.dbus_send(args, *proc_args, **proc_kwargs)


# #############################################################################
# commands
# #############################################################################


class Commands:
    def __init__(self, state):
        self.state = state
        self.cmd_mapping = [
            (['attach', 'a'], self.attach),
            (['edit', 'e'], self.external_edit),
            (['read', 'r'], self.read),
            (['attachClip', 'c'], self.attach_clip),
            (['openAttach', 'o'], self.open_last_attach),
            (['openUrl', 'u'], self.open_last_url),
            (['toggleNotifications', 'n'], self.toggle_notifications),
            (['toggleAutohide', 'h'], self.toggle_autohide),
            (['toggleContactsSort', 's'], self.toggle_sort_contacts),
            (['renameContact'], self.rename_contact),
            (['addContact'], self.add_contact),
            (['reload'], self.reload),
            (['quit', 'q'], self.quit),
        ]
        self.map = {cmd.lower(): fn for cmds, fn in self.cmd_mapping for cmd in cmds}

    def exec(self, cmd, *args):
        fn = self.map.get(cmd.lower())
        if fn is None:
            self.state.set_error(f"Command `{cmd}` not found")
            return
        try:
            return fn(*args)
        except TypeError as err:
            # Handle only the exceptions produced by giving the wrong number of arguments to `fn()`, not any exceptions produced inside executing `fn()` (i.e. deeper in the stack trace)
            if err.__traceback__.tb_next is not None:
                raise
            if re.search(r"missing \d+ required positional argument", str(err)):
                self.state.set_error(f':{cmd} missing arguments')
            elif re.search(r"takes \d+ positional arguments? but \d+ were given", str(err)):
                self.state.set_error(f':{cmd} extra arguments')
            else:
                raise

    @staticmethod
    def split_path(string):
        string = string.strip()
        if not string:
            return ['', '']
        PATH_RE = re.compile(
            r"""
                # Matches a path-like string, with whitespaces escaped or with the whole path in quotes.
                (
                    (
                        \\\ |           # escaped whitespace OR ..
                        [^'" ]          # .. not a quote or space
                    )+
                )                       # Path with escaped whitespace ..
                |                       # .. OR ..
                (                       # .. path in quotes.
                    (?P<quote>['"])     # a quote char; name the capture
                    .+?                 # anything, non-greedily
                    (?P=quote)          # matching quote
                )
                """,
            re.VERBOSE,
        )
        re_match = PATH_RE.match(string)
        if not re_match:
            return ['', string]
        path = re_match.group()
        if re_match.group(1):  # unquoted path
            path = path.replace(r'\ ', ' ')
        else:  # path in quotes
            path = path.strip('\'"')
        rest = string[re_match.end() :].strip()
        return [path, rest] if rest else [path]

    @staticmethod
    def is_path(path):
        return path.startswith(("/", "~/", "./"))

    def external_edit(self, *args):
        if self.state.current_contact is None:
            self.state.set_error(":edit Error: no contact currently selected")
            return

        filename = ''
        if args:
            filename, *message = Commands.split_path(*args)

        if Commands.is_path(filename):
            msg_file_path = os.path.expanduser(filename)
        else:
            msg_file_path = tmpfile = tempfile.NamedTemporaryFile(suffix='.md', delete=False).name
            message = args
        if message:
            with open(msg_file_path, "w") as msg_file:
                msg_file.write(*message)

        self.state.loop.stop()
        mk_call(self.state.cfg.editor_command + " " + shlex.quote(msg_file_path), use_pipe=False)
        print('Please wait...')
        self.state.loop.start()

        with open(msg_file_path, 'r') as msg_file:
            msg = msg_file.read().strip()
            if msg:
                self.state.signal.send_message(self.state.current_contact, msg)

        try:
            os.remove(tmpfile)
        except NameError:
            pass

    def read(self, path_or_cmd):
        if self.state.current_contact is None:
            self.state.set_error(":read Error: no contact currently selected")
            return

        message = ''
        if Commands.is_path(path_or_cmd):
            with open(os.path.expanduser(path_or_cmd), 'r') as file:
                message = file.read()
        elif path_or_cmd.startswith('!'):
            message = subprocess.check_output(['/bin/sh', '-c', path_or_cmd[1:].strip()]).decode("utf-8")

        if message != '':
            self.state.signal.send_message(self.state.current_contact, message)

    def open_file(self, path):
        if os.path.exists(path):
            if isinstance(path, dict):
                mk_call(self.state.cfg.open_command, path, True)
            mk_call(self.state.cfg.open_command, {'%u': path}, True)

    def attach(self, args):
        if self.state.current_contact is None:
            self.state.set_error(":attach Error: no contact currently selected")
            return

        attachment, *message = Commands.split_path(args)
        attachment = os.path.expanduser(attachment)
        if not os.path.isfile(attachment):
            self.state.set_error('File does not exist: ' + attachment)
            return
        self.state.signal.send_message(self.state.current_contact, *message, attachments=[attachment])

    def attach_clip(self, *message):
        if self.state.current_contact is None:
            self.state.set_error(":attachClip Error: no contact currently selected")
            return

        files = clip.files(self.state)

        if files:
            self.state.signal.send_message(self.state.current_contact, *message, attachments=files)
        else:
            self.state.set_notification('Clipboard is empty.')

    def open_attach(self, envelope):
        result = False
        attachments = get_envelope_attachments(envelope)
        for attachment in attachments:
            file_path = get_attachment_path(attachment)
            if file_path:
                self.open_file(file_path)
                result = True

        return result

    def open_last_attach(self):
        for txt in reversed(self.state.current_chat):
            if self.open_attach(txt.envelope):
                return

    def open_url(self, envelope):
        txt = get_envelope_msg(envelope)
        urls = get_urls(txt)
        if urls:
            mk_call(self.state.cfg.open_command, {'%u': urls[0]}, True)
            return True

        return False

    def open_last_url(self):
        for txt in reversed(self.state.current_chat):
            if self.open_url(txt.envelope):
                return

    def toggle_notifications(self):
        self.state.cfg.enable_notifications = not self.state.cfg.enable_notifications
        notif = 'Desktop notifications are '
        if self.state.cfg.enable_notifications:
            notif = notif + 'ON'
        else:
            notif = notif + 'OFF'
        self.state.set_notification(notif + '.')

    def toggle_autohide(self):
        self.state.cfg.contacts_autohide = not self.state.cfg.contacts_autohide

    def toggle_sort_contacts(self):
        self.state.cfg.contacts_sort_alpha = not self.state.cfg.contacts_sort_alpha
        self.reload()

    def send_notification(self, sender, message):
        if self.state.cfg.enable_notifications:
            mk_call(self.state.cfg.notification_command, {'%s': sender, '%m': message})

    def rename_contact(self, args):
        # :renameContact +NUMBER new name here  -> use +NUMBER number
        # :renameContact "Old Name" new name here  -> use contact named "Old Name"
        # :renameContact new name here          -> rename current contact or group
        try:
            number, new_name = Commands.split_path(args)
            if not is_number(number):
                for contact_id, contact in self.state.signal.contacts_map.items():
                    if contact["name"] == number:
                        is_group = is_contact_group(contact)
                        break
                else:  # contact with name `number` not found
                    raise ValueError
            elif self.state.signal.get_contact(number) is None:
                    self.state.set_error(f":renameContact Error: no contact with number {number} found")
                    return
            else:
                is_group = False
                contact_id = number
        except ValueError:
            if self.state.current_contact is None:
                self.state.set_error(":renameContact Error: no contact currently selected")
                return
            contact_id = self.state.current_contact.get('number')
            is_group = contact_id is None
            if is_group:
                contact_id = self.state.current_contact.get('groupId')
            new_name = args

        self.state.signal.daemon.rename_contact(contact_id, new_name, is_group, lambda *i: self.reload())

    def add_contact(self, args):
        # :addContact +NUMBER [Contact Name]
        try:
            number, name = args.split(maxsplit=1)
        except ValueError:
            number, name = args, ""
        if not is_number(number):
            self.state.set_error(f':addContact "{number}": not a valid number')
            return
        self.state.signal.daemon.rename_contact(number, name, is_group=False, callback=lambda *i: self.reload())


    def reload(self):
        self.state.reload()

    def quit(self):
        raise urwid.ExitMainLoop()


# #############################################################################
# signal
# #############################################################################


class Signal:
    signals = ['receive_message', 'send_message']

    def __init__(self, user):
        self.user = user
        self._data = None
        self._path = os.path.join(SIGNALCLI_DATA_FOLDER, user)

        if not os.path.exists(self._path):
            self._path = os.path.join(SIGNALCLI_LEGACY_DATA_FOLDER, user)
            if not os.path.exists(self._path):
                raise Exception(self.user + " does not exist!")

        self.daemon = Daemon(None)

        self.reload()

    def start_daemon(self):
        return self.daemon.start(self.user, self.envelope_handler)

    def envelope_handler(self, envelope):
        if get_nested(envelope, 'syncMessage', 'sentMessage') is not None:
            urwid.emit_signal(self, 'send_message', envelope)
        elif envelope.get('dataMessage') is not None:
            urwid.emit_signal(self, 'receive_message', envelope)
        else:
            logging.info('NOT_A_MESSAGE:%s', envelope)

    def reload(self):
        with open(self._path) as f:
            self._data = json.load(f)

        self.contacts = self._data['contactStore']['contacts']
        self.groups = [
            g
            for g in self._data["groupStore"]['groups']
            if g['name']
            # Older versions of `signal-cli` use `active` key while newer ones use `archived`.
            and (g.get('active') or not g.get('archived'))
        ]
        self.contacts_map = {c['number']: c for c in self.contacts}
        self.contacts_map.update({g['groupId']: g for g in self.groups})

    def send_message(self, contact, message="", attachments=[]):
        target = contact.get('number')
        is_group = target is None
        if is_group:
            target = contact.get('groupId')

        attachment_paths = [os.path.expanduser(attachment) for attachment in attachments]
        if not all([os.path.exists(attachment_path) for attachment_path in attachment_paths]):
            logging.warning('send_message: Attached file(s) does not exist.')
            return

        ts = int(datetime.now().timestamp() * 1000)
        envelope = {
            'source': self.user,
            'target': target,
            'timestamp': ts,
            'dataMessage': {'message': message, 'attachments': attachments, 'timestamp': ts},
        }

        def after_send_proc_returns(_proc):
            # Remove temproary attachments
            for attachment in envelope['dataMessage']['attachments']:
                if attachment.startswith(os.path.join(tempfile.gettempdir(), clip.tempfile_prefix)):
                    os.remove(attachment)

        self.daemon.send_message(message, attachment_paths, target, is_group, callback=after_send_proc_returns)

        logging.info('send_message:%s', envelope)
        urwid.emit_signal(self, 'send_message', envelope)

    def get_contact(self, number_or_id):
        return self.contacts_map.get(number_or_id)

    def get_envelope_contact(self, envelope):
        contact_id = get_envelope_contact_id(envelope)
        contact = self.get_contact(contact_id)
        if not contact:
            logging.critical('NULL_CONTACT:%s', envelope)
        return contact

    def get_contact_profile_name(self, contact):
        try:
            profiles = self._data['profileStore']['profiles']
            profiles_map = {p['name']: p for p in profiles}
            contact_id = hash_contact(contact)
            return profiles_map[contact_id]['profile']['name']
        except KeyError:
            return None




urwid.register_signal(Signal, Signal.signals)

# #############################################################################
# ContactsWindow
# #############################################################################


class ContactsWindow(urwid.ListBox):
    signals = ['notify_count_changed']

    def __init__(self, state):
        self.state = state
        self._body = []

        super().__init__(urwid.SimpleFocusListWalker(self._body))

        self.reload()

        for contact_id, notify_count in self.state.notify_counts.items():
            contact_widget = self.contact_widgets_map[contact_id]
            self.set_contact_widget_notify_count(contact_widget, notify_count)

        urwid.connect_signal(self.state.signal, 'receive_message', self.on_new_message)
        urwid.connect_signal(self.state.signal, 'send_message', self.on_new_message)
        urwid.connect_signal(self.state, 'current_contact_changed', self.on_current_contact_changed)

    def reload(self):
        self.set_contacts(self.make_formatted_contacts_list())

    def make_formatted_contacts_list(self):
        def sorter(contact):
            contact_name = get_contact_name(contact)
            if self.state.cfg.contacts_sort_alpha:
                return contact_name.lower()
            try:
                chat = self.state.chats[hash_contact(contact)]
                last_envelope = chat[-1].envelope
            except (KeyError, IndexError):
                return (0, contact_name.lower())
            return (-get_envelope_time(last_envelope), contact_name.lower())

        if not self.state.cfg.group_contacts:
            return sorted(self.state.signal.contacts_map.values(), key=sorter)
        else:
            grps = sorted(self.state.signal.groups, key=sorter)
            conts = sorted(self.state.signal.contacts, key=sorter)
            return [
                    'Groups',
                    '---',
                    *grps,
                    '---',
                    'Contacts',
                    '---',
                    *conts
                ]

    def mk_contact_widget_markup(self, contact):
        notify_count = self.state.notify_counts.get(hash_contact(contact), 0)
        markup = [] if notify_count == 0 else [('bold', '({}) '.format(notify_count))]

        name = get_contact_name(contact)
        markup.append(name)
        if is_number(name):
            if name == self.state.cfg.username:
                markup.append(('italic', ' (Self)'))
            else:
                profile_name = self.state.signal.get_contact_profile_name(contact)
                if profile_name:
                    markup.append(('italic', ' ~' + profile_name))

        if is_contact_group(contact) and not self.state.cfg.group_contacts:
            markup.append(('italic', ' [GRP]'))

        return markup

    def set_contact_notify_count(self, contact, count):
        self.state.set_contact_notify_count(hash_contact(contact), count)
        total_notify_count = sum(self.state.notify_counts.values())
        urwid.emit_signal(self, 'notify_count_changed', total_notify_count)

    def set_contact_widget_notify_count(self, w, count):
        if not w:
            return
        self.set_contact_notify_count(w.contact, count)
        w.original_widget.set_text(self.mk_contact_widget_markup(w.contact))

    def on_current_contact_changed(self, _old, _current, _focus=False):
        self.set_contact_widget_notify_count(self.focus, 0)

    def on_new_message(self, envelope):
        if get_envelope_msg(envelope) is None and not get_envelope_attachments(envelope):
            return

        contact_id = get_envelope_contact_id(envelope)
        contact = self.state.signal.get_contact(contact_id)
        contact_widget = self.contact_widgets_map.get(contact_id)

        if contact != self.state.current_contact and not is_envelope_outgoing(envelope):
            if contact_widget is None:
                self.set_contact_notify_count(contact, '+1')
            else:
                self.set_contact_widget_notify_count(contact_widget, '+1')

        if not self.state.cfg.contacts_sort_alpha and contact_widget is not None:
            self.move_contact_top(contact_widget)

    def move_contact_top(self, w):
        if self.state.cfg.group_contacts:
            is_group = is_contact_group(w.contact)
            offset = 2 + (0 if is_group else (3 + len(self.state.signal.groups)))
        else:
            offset = 0

        ind = self._body.index(w)
        if ind == offset:
            return
        self._body.insert(offset, self._body.pop(ind))

        self.focus_position = offset

    def set_contacts(self, contacts):
        self._body.clear()

        def mk_contact(x):
            widget = None
            contact = None
            if x == '---':
                widget = urwid.Divider('-')
            elif isinstance(x, str):
                widget = urwid.Text(('bold', '~~ ' + x + ' ~~'), align='center')
            else:
                widget = urwid.Text(self.mk_contact_widget_markup(x))
                contact = x

            am = urwid.AttrMap(widget, None, focus_map={None: 'reversed', 'italic': 'reverseditalic'})
            am.contact = contact
            return am

        contact_widgets = [mk_contact(x) for x in contacts]
        self._body.extend(contact_widgets)
        self.contact_widgets_map = {hash_contact(w.contact): w for w in contact_widgets if w.contact}

        self.focus_first()

    def get_focused_contact(self):
        return self.focus.contact

    def focus_next(self, num=1):
        try:
            self.focus_position = self.focus_position + num
            if not self.get_focused_contact():
                self.focus_next()
        except IndexError:
            pass

    def focus_prev(self, num=1):
        try:
            if not self.state.cfg.group_contacts or self.focus_position > 2:
                self.focus_position = self.focus_position - num
                if not self.get_focused_contact():
                    self.focus_prev()
        except IndexError:
            pass

    def focus_first(self):
        try:
            if self.state.cfg.group_contacts:
                self.focus_position = 2
            else:
                self.focus_position = 0
        except IndexError:
            pass

    def focus_last(self):
        try:
            self.focus_position = len(self._body) - 1
        except IndexError:
            pass

    def keypress(self, size, key):
        if key in ('enter', 'l'):
            if self.get_focused_contact():
                self.state.set_current_contact(self.get_focused_contact(), key == 'enter')
        elif key in ('j', 'down'):
            self.focus_next()
        elif key in ('k', 'up'):
            self.focus_prev()
        elif key == 'page down':
            self.focus_next(num=10)
        elif key == 'page up':
            self.focus_prev(num=10)
        elif key == 'g':
            self.focus_first()
        elif key == 'G':
            self.focus_last()
        elif key == 'r':
            self.state.reload()
        return key


class LeftWindow(urwid.Frame):
    def __init__(self, state):
        self.state = state
        self._wcontacts = ContactsWindow(self.state)
        self._wsearch = Edit(('bold', '> '))

        urwid.connect_signal(self._wsearch, 'postchange', self.on_search_text_changed)

        super().__init__(self._wcontacts, footer=None)

        if not self.state.cfg.group_contacts:
            self.header = urwid.Pile([urwid.Text(btxt('Contacts'), align='center'), urwid.Divider('-')])

    def start_search(self):
        self.footer = self._wsearch
        self.focus_position = 'footer'
        self._formatted_contacts = self._wcontacts.make_formatted_contacts_list()

    def hide_search(self):
        self.focus_position = 'body'
        self.footer = None

    def clear_search(self):
        self._formatted_contacts = self._wcontacts.make_formatted_contacts_list()
        self._wsearch.set_edit_text('')

    def set_contacts(self, contacts):
        self._wcontacts.set_contacts(contacts)

    def on_search_text_changed(self, _sender, _old_text):
        txt = self._wsearch.get_edit_text()

        def contact_match(contact):
            if isinstance(contact, str):
                return True
            return (txt.lower() in get_contact_name(contact).lower()) or (txt in get_contact_number(contact))

        results = [c for c in self._formatted_contacts if contact_match(c)]
        self.set_contacts(results)

    def keypress(self, size, key):
        key = super().keypress(size, key)
        if key == '/':
            self.start_search()
        elif key == 'enter' and self.focus_position == 'footer':
            self.hide_search()
        elif key == 'esc':
            self.hide_search()
            self.clear_search()
        return key


# #############################################################################
# ChatWindow
# #############################################################################


class ChatWindow(urwid.Frame):
    def __init__(self, state):
        self.state = state
        self.pop_up_action = None

        self.search_mode = False
        self.search_list = urwid.SimpleFocusListWalker([])

        self._wsearch = urwid.ListBox(self.search_list)
        self._wtitle = urwid.Text('')
        self._wline = Edit(('bold', '> '))
        self._wdiv = urwid.Divider('-')
        self._wlist = urwid.ListBox([])

        self._w = urwid.WidgetPlaceholder(self._wlist)
        wcontext = urwid.Frame(self._w, header=urwid.Divider('-'))
        self._wcontext = urwid.Frame(wcontext, header=self._wtitle, footer=self._wdiv)

        super().__init__(self._wcontext, footer=self._wline)

        urwid.connect_signal(self._wline, 'postchange', self.on_edit_text_changed)
        urwid.connect_signal(self.state, 'current_contact_changed', self.on_current_contact_changed)
        urwid.connect_signal(self.state, 'dialog_requested', self.show_pop_up)
        urwid.connect_signal(self.state.signal, 'receive_message', self.on_new_message)
        urwid.connect_signal(self.state.signal, 'send_message', self.on_new_message)

    def show_pop_up(self, widget):
        def on_pop_up_closed(sender, accepted, result):
            self.remove_pop_up()
            urwid.emit_signal(self.state, 'dialog_finished', accepted, result)

        wrapper = PopUpWrapper(widget)
        urwid.connect_signal(wrapper, 'closed', on_pop_up_closed)

        popup = urwid.Overlay(
            wrapper,
            self._w.original_widget,
            align='center',
            valign='middle',
            width=('relative', 85),
            height=('relative', 75),
        )

        self._w.original_widget = popup
        return wrapper

    def remove_pop_up(self, _sender=None):
        if self.search_mode:
            self._w.original_widget = self._wsearch
        else:
            self._w.original_widget = self._wlist

    def on_edit_text_changed(self, _sender, _old_text):
        txt = self.get_edit_text()
        if txt.startswith('/'):
            if not self.search_mode:
                self.search_mode = True
                self._w.original_widget = self._wsearch
            self.search_in_chat()
        elif self.search_mode:
            self.search_mode = False
            self._w.original_widget = self._wlist

    def search_in_chat(self):
        if not self.search_mode:
            return

        search_txt = self.get_edit_text()[1:]

        def setx(i, txt):
            txt.real_index = i
            return txt

        found = [
            setx(i, txt) for i, txt in enumerate(self.state.current_chat) if search_txt in txt.original_widget.text
        ]
        self.search_list.clear()
        self.search_list.extend(found)

    def on_new_message(self, _envelope):
        self.focus_chatlast()

    def is_focused_input(self):
        return self.focus_position == 'footer'

    def is_focused_chat(self):
        return self.focus_position == 'body'

    def focus_input(self):
        self.focus_position = 'footer'

    def focus_chat(self):
        self.focus_position = 'body'

    def focus_chatfirst(self):
        try:
            self._w.original_widget.focus_position = 0
        except IndexError:
            pass

    def focus_chatlast(self):
        try:
            self._w.original_widget.focus_position = len(self._w.original_widget.body) - 1
        except IndexError:
            pass

    def get_edit_text(self):
        return self._wline.get_edit_text()

    def set_edit_text(self, txt, move_cursor_to_end=False):
        self._wline.set_edit_text(txt)
        if move_cursor_to_end:
            self._wline.set_edit_pos(len(txt))

    def set_title(self, contact):
        num = contact.get("number")
        if not num:
            # see this: https://github.com/isamert/scli/issues/53#issuecomment-612571462
            contacts = [
                self.state.signal.get_contact(contact if isinstance(contact, str) else contact['number']) or contact
                for contact in contact['members']
            ]
            num = ', '.join([get_contact_name(contact) for contact in contacts])

        self._wtitle.set_text([('bold', get_contact_name(contact)), ' (', num, ')'])

    def on_current_contact_changed(self, old, current, focus=False):
        self.set_title(current)
        listbox_set_body(self._wlist, self.state.current_chat)
        self.focus_chatlast()

    def get_current_envelope(self):
        try:
            if self.search_mode:
                return self.search_list[self._wsearch.focus_position].envelope
            return self.state.current_chat[self._wlist.focus_position].envelope
        except (IndexError, AttributeError):
            return None

    def auto_complete_commands(self, txt):
        splitted_txt = txt.split(' ')
        if len(splitted_txt) > 1:
            path, *messages = Commands.split_path(' '.join(splitted_txt[1:]))

            # Check we are trying to complete a path
            if len(messages) > 0 or not Commands.is_path(path):
                return

            fullpath = os.path.expanduser(path)
            dirname = os.path.dirname(fullpath)
            if not os.path.isdir(dirname):
                return

            possible_paths = [x for x in os.listdir(dirname) if os.path.join(dirname, x).startswith(fullpath)]
            commonprefix = os.path.commonprefix(possible_paths)

            self.state.set_notification('|'.join(possible_paths))

            completion = ''
            if commonprefix != '':
                completion = os.path.join(os.path.dirname(path), commonprefix)
            if os.path.isdir(os.path.expanduser(completion)) and not completion.endswith('/'):
                completion = completion + '/'
            if ' ' in completion:
                completion = '"' + completion + '"'

            if completion != '':
                self.set_edit_text(splitted_txt[0] + ' ' + completion, True)
        else:
            all_commands = [
                cmd
                for cmd in [tupl[0][0] for tupl in self.state.commands.cmd_mapping]
                if cmd.lower().startswith(txt[1:].lower())
            ]
            commonprefix = os.path.commonprefix(all_commands)

            self.state.set_notification('{' + '|'.join(all_commands) + '}')

            if len(all_commands) == 1:
                self.set_edit_text(':' + all_commands[0] + ' ', True)
            elif commonprefix != '':
                self.set_edit_text(':' + commonprefix, True)

    def keypress(self, size, key):
        key = super().keypress(size, key)

        if self.is_focused_input():
            txt = self.get_edit_text()
            if key == 'enter':
                if txt.startswith(':'):
                    if txt.strip() == ":":
                        self.state.set_error('Command missing after `:`')
                        return key
                    cmd, *args = txt[1:].split(maxsplit=1)
                    self.state.commands.exec(cmd, *args)
                elif txt.startswith('/'):
                    pass
                elif txt.strip(' ') != '' and self.state.current_contact:
                    self.state.signal.send_message(self.state.current_contact, txt)
                self.set_edit_text('')
            elif key == 'tab':
                if txt.startswith(':'):
                    self.auto_complete_commands(txt)
                    return
        elif not self.state.current_chat:
            return key
        elif self.is_focused_chat():
            envelope = self.get_current_envelope()
            if key in ('enter', 'l'):
                if self.search_mode:
                    real_index = self.search_list[self._wsearch.focus_position].real_index
                    self.set_edit_text('')
                    self._wlist.focus_position = real_index
                else:
                    self.state.commands.open_attach(envelope) or self.state.commands.open_url(envelope)
            elif key == 'o':
                self.state.commands.open_url(envelope) or self.state.commands.open_attach(envelope)
            elif key in ('j', 'down'):
                listbox_focus_next(self._w.original_widget)
            elif key in ('k', 'up'):
                listbox_focus_prev(self._w.original_widget)
            elif key == 'g':
                self.focus_chatfirst()
            elif key == 'G':
                self.focus_chatlast()
            elif key == 'y':
                txt = get_envelope_msg(envelope)
                clip.put(self.state, txt)
            elif key == 'd':
                if self.search_mode:
                    item = self.search_list[self._wsearch.focus_position]
                    real_index = item.real_index
                    del self.search_list[self._wsearch.focus_position]
                    del self.state.current_chat[real_index]
                else:
                    del self.state.current_chat[self._wlist.focus_position]
            elif key == 'i':
                self.show_pop_up(MessageInfo(self.state, envelope))
            elif key == 'q':
                # TODO: quote (https://github.com/AsamK/signal-cli/issues/151)
                pass
        return key


# #############################################################################
# MainWindow
# #############################################################################


class MainWindow(urwid.Frame):
    def __init__(self, state):
        self.state = state

        # ui
        self.current_focus = 'contacts'
        self._wleft = LeftWindow(self.state)
        self._wchat = ChatWindow(self.state)
        self._wstatus = urwid.Text("...")
        self._wnotify_count = urwid.Text("...")

        self._wrapped_left = NiceBox(self._wleft)
        self._wrapped_chat = NiceBox(self._wchat)
        self._widgets = [('weight', 1, self._wrapped_left), ('weight', 3, self._wrapped_chat)]
        self._wcontext = urwid.Columns(widget_list=self._widgets, dividechars=0, focus_column=0)
        super().__init__(self._wcontext, footer=urwid.Columns([self._wstatus, ('pack', self._wnotify_count)]))

        # signals
        urwid.connect_signal(self.state, 'current_contact_changed', self.on_current_contact_changed)
        urwid.connect_signal(self.state, 'status_changed', self.on_status_changed)
        urwid.connect_signal(self.state, 'reload_request', self.reload)
        urwid.connect_signal(self.state, 'notification_changed', self.on_notification_changed)
        urwid.connect_signal(self.state, 'error_changed', self.on_error_changed)
        urwid.connect_signal(self.state.cfg, 'changed', self.on_cfg_changed)
        urwid.connect_signal(self._wleft._wcontacts, 'notify_count_changed', self.on_notify_count_changed)

    def reload(self):
        self._wleft._wcontacts.reload()

    def set_status(self, txt):
        self._wstatus.set_text(txt)

    def toggle_contacts(self):
        if len(self._wcontext.contents) == 2:
            if self.current_focus == 'contacts':
                self.focus_next()

            self._wcontext.contents.clear()
            self._wcontext.contents.append((self._wrapped_chat, self._wcontext.options(width_amount=3)))
        else:
            self._wcontext.contents.insert(0, (self._wrapped_left, self._wcontext.options(width_amount=1)))

    def body_pos(self):
        if len(self._wcontext.contents) == 1:
            return 0
        return 1

    def focus_input(self, cmd_mode=False, search_mode=False):
        if self.current_focus == 'contacts' and self.state.cfg.contacts_autohide:
            self.toggle_contacts()

        self.focus_position = 'body'
        self._wcontext.set_focus(self.body_pos())
        self._wchat.focus_input()
        self.current_focus = 'input'

        if cmd_mode:
            self._wchat.set_edit_text(':', True)
        elif search_mode:
            self._wchat.set_edit_text('/', True)

    def focus_contacts(self):
        if len(self._wcontext.contents) == 1:
            self.toggle_contacts()

        self.focus_position = 'body'
        self._wcontext.set_focus(0)
        self.current_focus = 'contacts'

    def focus_chat(self):
        self.focus_position = 'body'
        self._wcontext.set_focus(self.body_pos())
        self._wchat.focus_chat()
        self.current_focus = 'chat'

    def focus_next(self):
        if self.current_focus == 'contacts':
            self.focus_chat()
            if self.state.cfg.contacts_autohide:
                self.toggle_contacts()
        elif self.current_focus == 'chat':
            self.focus_input()
        elif self.current_focus == 'input':
            self.focus_contacts()

    def focus_prev(self):
        if self.current_focus == 'contacts':
            self.focus_input()
        elif self.current_focus == 'chat':
            self.focus_contacts()
        elif self.current_focus == 'input':
            self.focus_chat()

    def show_help_pop_up(self):
        if self.current_focus == 'contacts':
            self._wchat.show_pop_up(HelpDialog())
        elif self.current_focus == 'chat':
            self._wchat.show_pop_up(HelpDialog())

    def on_current_contact_changed(self, old, current, focus=False):
        if self.state.status_data is self.state.current_contact:
            self.state.set_status('')

        if focus:
            self.focus_input()

    def on_status_changed(self, status, data):
        self.set_status(status)

    def on_notification_changed(self, notif, data):
        self.set_status(notif)

    def on_error_changed(self, err):
        self.set_status(err)

    def on_cfg_changed(self, key, val):
        if key == 'contacts_autohide':
            self.toggle_contacts()

    def on_notify_count_changed(self, count):
        self._wnotify_count.set_text(btxt(str(count)))

    def keypress(self, size, key):
        key = super().keypress(size, key)

        if key == 'tab':
            self.focus_next()
        elif key == 'shift tab':
            self.focus_prev()
        elif key == ':':
            self.focus_input(cmd_mode=True)
        elif key == '/' and self.current_focus == 'chat':
            self.focus_input(search_mode=True)
        elif key == '?':
            self.show_help_pop_up()

        return key


# #############################################################################
# state
# #############################################################################


class State:
    signals = [
        'current_contact_changed',
        'status_changed',
        'notification_changed',
        'error_changed',
        'dialog_requested',
        'dialog_finished',
        'reload_request',
    ]

    def __init__(self, cfg):
        self.signal = Signal(cfg.username)
        self.cfg = cfg
        self.chats = collections.defaultdict(lambda: urwid.SimpleFocusListWalker([]))
        self.error = ''
        self.status = ''
        self.notification = ''
        self.status_data = None
        self.current_contact = None
        self.current_chat = None
        self.loop = None
        self.notify_counts = {}

        self.commands = Commands(self)

        self.load_history()
        atexit.register(self.save_history)

        urwid.connect_signal(self.signal, 'receive_message', self.on_receive_message)
        urwid.connect_signal(self.signal, 'send_message', self.on_send_message)

    def reload(self):
        self.signal.reload()
        if self.current_contact is not None:
            contact_id = self.current_contact.get("number") or self.current_contact.get("groupId")
            current_contact_reloaded = self.signal.get_contact(contact_id)
            self.set_current_contact(current_contact_reloaded)
        urwid.emit_signal(self, 'reload_request')

    def set_current_contact(self, contact, focus=False):
        old = self.current_contact
        self.current_contact = contact
        self.current_chat = self.chats[hash_contact(contact)]
        urwid.emit_signal(self, 'current_contact_changed', old, contact, focus)

    def set_status(self, status, data=None):
        self.status = status
        self.status_data = data
        urwid.emit_signal(self, 'status_changed', status, data)

    def set_notification(self, notif, data=None):
        self.notification = notif
        self.status_data = data
        urwid.emit_signal(self, 'notification_changed', notif, data)

    def set_error(self, err):
        self.error = err
        urwid.emit_signal(self, 'error_changed', err)

    def set_contact_notify_count(self, contact_id, count):
        if count == '+1':
            count = self.notify_counts.get(contact_id, 0) + 1
        self.notify_counts[contact_id] = count

    def show_dialog(self, w):
        urwid.emit_signal(self, 'dialog_requested', w)

    def get_chat_for_envelope(self, envelope):
        contact = self.signal.get_envelope_contact(envelope)
        return self.chats[hash_contact(contact)]

    def on_send_message(self, envelope):
        self.print_sent_message(envelope)

    def on_receive_message(self, envelope):
        msg = get_envelope_msg(envelope)
        sender = self.signal.get_envelope_contact(envelope)
        contact_name = get_contact_name(sender)

        if msg is None:
            logging.info('NOT_A_MESSAGE:%s', envelope)
            return
        logging.info('MESSAGE:%s', envelope)

        if sender != self.current_contact:
            notif = 'New message from ' + contact_name + ': "' + msg + '"'
            self.set_notification(notif, sender)

        formatted_message = self.print_received_message(envelope)
        self.commands.send_notification(contact_name, to_txt(formatted_message))

    def format_msg(self, message):
        message = '\n'.join(textwrap.wrap(message, width=self.cfg.wrap_at))

        if not self.cfg.use_formatting:
            return ntxt(message)

        i, m = 0, []
        while i < len(message):
            c = message[i]
            if c in ('_', '*', '~'):
                try:
                    end = message[i + 1 :].index(c)
                    sub = message[i + 1 : i + 1 + end]
                    m.append(c)
                    m.append((FORMAT_MAP[c], sub))
                    m.append(c)
                    i = i + 2 + end
                except ValueError:
                    m.append(c)
                    i = i + 1
            else:
                m.append(c)
                i = i + 1

        if not m:
            m = " "
        return m

    def print_received_message(self, envelope):
        source = envelope['source']
        is_group = is_envelope_group_message(envelope)
        attachments = get_envelope_attachments(envelope)

        txt = [btxt('>> ')]
        if is_group or self.cfg.show_names:
            contact = self.signal.get_contact(source)
            if contact:
                txt.append(ibtxt(get_contact_name(contact)))
            else:
                txt.append(btxt(source))
            txt.append(btxt(' | '))

        message = self.format_msg(get_envelope_msg(envelope))
        attachments = get_envelope_attachments(envelope)

        if attachments != []:
            attachments_txt = ', '.join(
                [get_attachment_name(attachment) + ' (' + str(i) + ')' for i, attachment in enumerate(attachments)]
            )
            txt.append(ntxt('[attached: ' + attachments_txt + '] '))

        txt.append(message)
        wtxt = FocusableText(txt)
        wtxt.envelope = envelope
        bisect.insort(self.get_chat_for_envelope(envelope), wtxt)

        return txt[1:]

    def print_sent_message(self, envelope):
        message = self.format_msg(get_envelope_msg(envelope))
        attachments = get_envelope_attachments(envelope)

        txt = []
        if len(attachments) > 0:
            anames = ', '.join([get_attachment_name(attachment) for attachment in attachments])
            txt.append(ntxt('[attached: '))
            txt.append(itxt(anames))
            txt.append(ntxt('] '))
            txt.append(ntxt(message))
        else:
            txt.append(message)

        if self.cfg.one_sided:
            align = 'left'
            txt.insert(0, btxt('>> '))
            if self.cfg.show_names:
                txt.insert(1, btxt('You | '))
        else:
            align = 'right'
            if self.cfg.show_names:
                txt.append(btxt(' | You'))
            txt.append(btxt(" <<"))

        wtxt = FocusableText(txt, align=align)
        wtxt.envelope = envelope
        bisect.insort(self.get_chat_for_envelope(envelope), wtxt)

        return txt[:-1]

    def save_history(self):
        if not self.cfg.save_history:
            return

        envelopes = [x.envelope for vals in self.chats.values() for x in vals]
        notify_counts = {contact_id: count for (contact_id, count) in self.notify_counts.items() if count != 0}
        items = {'envelopes': envelopes, 'notify_counts': notify_counts}

        with open(SCLI_HISTORY_FILE, 'w') as history_file:
            json.dump(items, history_file)

    def load_history(self):
        if not self.cfg.save_history or not os.path.exists(SCLI_HISTORY_FILE):
            return

        with open(SCLI_HISTORY_FILE, 'r') as history_file:
            history = json.load(history_file)

        for envelope in history['envelopes']:
            if is_envelope_outgoing(envelope):
                self.print_sent_message(envelope)
            else:
                self.print_received_message(envelope)

        self.notify_counts = history.get('notify_counts', {})


urwid.register_signal(State, State.signals)

# #############################################################################
# main
# #############################################################################


def parse_cfg_file(cfg_file_path):
    vars = {}
    cfg_file_path = os.path.expanduser(cfg_file_path)
    if os.path.exists(cfg_file_path):
        with open(cfg_file_path) as cfg_file:
            for line in cfg_file:
                if not line.startswith('#') and line.strip() != "":
                    name, var = line.partition("=")[::2]
                    vars[name.strip().replace('-', '_')] = var.strip()
    elif cfg_file_path != SCLI_CFG_FILE and cfg_file_path != "":
        print('Given config file not found: ' + cfg_file_path, file=sys.stderr)
        sys.exit(2)

    return vars


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-c',
        '--config-file',
        type=str,
        default=SCLI_CFG_FILE,
        help='Config file. Configs in this file overrides every other config supplied by command line. (Default: '
        + SCLI_CFG_FILE
        + ')',
    )

    parser.add_argument('-u', '--username', type=str, help='Phone number starting with "+" followed by country code.')

    parser.add_argument(
        '-n',
        '--enable-notifications',
        default=False,
        action='store_true',
        help='Enable desktop notifications. (Also see --notification-command)',
    )

    parser.add_argument(
        '-N',
        '--notification-command',
        type=str,
        default="notify-send scli '%s - %m'",
        help='The command to run when a new message arrives. %%m is replaced with the message, %%s is replaced with the sender. (Default is "notify-send scli \'%%s - %%m\'',
    )

    parser.add_argument(
        '-o',
        '--open-command',
        type=str,
        default='xdg-open "%u"',
        help='File/URL opener command. %%u is replaced with the path. (Default is "xdg-open %%u")',
    )

    parser.add_argument(
        '-e',
        '--editor-command',
        type=str,
        default='$EDITOR',
        help='A text editor command to edit your messages externally.',
    )

    parser.add_argument(
        '-G',
        '--clipboard-get-command',
        type=str,
        default="",
        help='A command that returns a valid file path(s). When user calls `:attachClip` or `:c`, this command is executed and the returned file(s) will be added as attachment(s). The command should return one absolute file path per each line. (Default uses `xclip`)',
    )

    parser.add_argument(
        '-P',
        '--clipboard-put-command',
        type=str,
        default="",
        help='A command that puts given text to clipboard. %%s will be replaced with the text. (Default uses `xclip`.',
    )

    parser.add_argument(
        '-s',
        '--save-history',
        default=False,
        action='store_true',
        help='Enable saving history. History is saved as plain text. (Disabled by default.)',
    )

    parser.add_argument(
        '-f',
        '--use-formatting',
        default=False,
        action='store_true',
        help='Use _italic_, *bold*, ~strikethrough~ formatting in messages. (Disabled by default.)',
    )

    parser.add_argument('-w', '--wrap-at', type=int, default=300, help='Wrap messages at given column.')

    parser.add_argument(
        '--one-sided',
        default=False,
        action='store_true',
        help='Show messages aligned to one side in message list. (Disabled by default.)',
    )

    parser.add_argument(
        '--show-names',
        default=False,
        action='store_true',
        help='Show contact names even in message list even if it is one-to-one conversation. (Disabled by default.)',
    )

    parser.add_argument(
        '--group-contacts',
        default=False,
        action='store_true',
        help='Show groups and contacts seperately under the left pane. (Disabled by default)',
    )

    parser.add_argument(
        '--contacts-autohide',
        default=False,
        action='store_true',
        help='Autohide the contacts pane when it loses focus. (Disabled by default)',
    )

    parser.add_argument(
        '--contacts-sort-alpha',
        default=False,
        action='store_true',
        help='Sort contacts alphabetically. (Default: sort by the most recent message)',
    )

    parser.add_argument('--no-daemon', action='store_true', help='Not really useful.')

    parser.add_argument('--debug', default=False, action='store_true')

    cfg = parser.parse_args()
    file_cfg = parse_cfg_file(cfg.config_file)
    for key, val in file_cfg.items():
        attr = getattr(cfg, key)
        if isinstance(attr, bool):
            setattr(cfg, key, val.lower() in ['true', 't', 'yes', 'y'])
        elif isinstance(attr, int):
            setattr(cfg, key, int(val))
        else:
            setattr(cfg, key, val)

    if not os.path.exists(SCLI_DATA_FOLDER):
        try:
            os.makedirs(SCLI_DATA_FOLDER)
        except OSError as exc:
            if not (exc.errno == errno.EEXIST and os.path.isdir(SCLI_DATA_FOLDER)):
                print("Can't create data directory.", file=sys.stderr)
                sys.exit(3)

    if cfg.debug:
        logging.basicConfig(filename=SCLI_LOG_FILE, level=logging.DEBUG)
    else:
        logging.basicConfig(filename=SCLI_LOG_FILE, level=logging.CRITICAL)

    if not cfg.username:
        ulist = []
        for folder in [SIGNALCLI_DATA_FOLDER, SIGNALCLI_LEGACY_DATA_FOLDER]:
            try:
                users = [x for x in os.listdir(folder) if os.path.isfile(os.path.join(folder, x))]
                ulist.extend(users)
            except FileNotFoundError:
                pass

        if not ulist:
            print("Couldn't find any linked device.", file=sys.stderr)
            sys.exit(1)
        elif len(ulist) == 1:
            cfg.username = ulist[0]
        else:
            print("Use one of these:", file=sys.stderr)
            for u in ulist:
                print("\tscli --username=" + u, file=sys.stderr)
            sys.exit(1)

    state = State(ObservableConfig(cfg))
    window = MainWindow(state)

    loop = urwid.MainLoop(window, palette=PALETTE)
    state.loop = state.signal.daemon._urwid_loop = loop

    if not cfg.no_daemon:
        proc = state.signal.start_daemon()
        atexit.register(proc.kill)

    loop.run()


if __name__ == "__main__":
    main()
